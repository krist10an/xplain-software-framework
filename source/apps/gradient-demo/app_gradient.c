/**
 * \file
 *
 * \brief Display gradient demo widget application
 *
 * Copyright (C) 2009 Atmel Corporation. All rights reserved.
 *
 * \page License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 * Atmel AVR product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

#include <led.h>
#include <board.h>
#include <string.h>

#include <gfx/gfx.h>
#include <gfx/win.h>
#include <gfx/wtk.h>
#include <gfx/sysfont.h>
#include <membag.h>
#include <debug.h>
#include <mainloop.h>
#include <string.h>
#include <stream.h>

#include "app_gradient.h"

/**
 * \weakgroup app_widget_group
 *
 * @{
 */

/**
 * \brief Event command ID for the application widgets.
 *
 * \note The command IDs cannot be 0, since this value is reserved for no
 * command event callback for certain widgets.
 */
enum app_widget_ids {
	//! Event command ID for the button.

	BUTTON_UPDATE_ID = 1,
	BUTTON_MIRROR_ID,
	BUTTON_INVERT_ID,
	
};

/**
 * \name Color scheme
 *
 * @{
 */

//! Background color for application
#define APP_BACKGROUND_COLOR        GFX_COLOR(50, 50, 50)

//! @}

/**
 * \name Widget sizes and positions
 *
 * @{
 */

//! Label position on top of display
#define LABEL_POS_X                 20
//! Label position on top of display
#define LABEL_POS_Y                 10

//! Slider position
#define SLIDER_POS_X                20
//! Slider position
#define SLIDER_POS_Y                120
//! Slider size on display
#define SLIDER_SIZE_X               80
//! Slider size on display
#define SLIDER_SIZE_Y               30

//! Spacing from slider to slider
#define SLIDER_SPACING_Y            10
//! Spacing from slider to slider
#define SLIDER_SPACING_X            200


//! Spacing from slider to button
#define BUTTON_SPACING_X            100
//! Spacing from slider to button
#define BUTTON_SPACING_Y            10

//! Button position
#define BUTTON_POS_Y                SLIDER_POS_Y
//! Button size on display
#define BUTTON_SIZE_X               SLIDER_SIZE_X
//! Button size on display
#define BUTTON_SIZE_Y               SLIDER_SIZE_Y

//! Slider position
#define FRAME_POS_X                20
//! Slider position
#define FRAME_POS_Y                40
//! Slider size on display
#define FRAME_SIZE_X               280
//! Slider size on display
#define FRAME_SIZE_Y               70
//! @}

/**
 * \name Widget configurations
 *
 * @{
 */

//! Max value for slider
#define SLIDER_MAX_VALUE            255

//! @}

/**
 * \name Static text strings
 *
 * @{
 */

//! Description for label
const static char                   *demo_string = "Demonstrating gradients";

//! @}

/**
 * \name Static variables
 *
 * @{
 */

//! Pointer to frame for application
static struct wtk_basic_frame       *frame;
//! Pointers to the sliders
static struct wtk_slider            *slider[6];
//! Frame background bitmap
static struct gfx_bitmap            frame_background;
//! Pointer to the sub-frame
static struct wtk_basic_frame       *sub_frame;
//! Sub-frame background bitmap
static struct gfx_bitmap            sub_frame_background;
//! Sub-frame background gradient
static struct gfx_gradient          sub_frame_gradient;
//! Storage for gradient options
uint8_t                             gradient_option;

//! @}

/**
 * \brief Frame command events handler
 *
 * This function handles the command events generated by the widgets.
 *
 * \sa wtk_basic_frame_command_handler_t
 */
static bool widget_frame_command_handler(struct wtk_basic_frame *frame,
		win_command_t command_data)
{
	char command = (char)(uintptr_t)command_data;

	switch (command) {

	case BUTTON_UPDATE_ID:
		//Recalculate the gradient, using the six sliders as inputs.
		gfx_gradient_set_values(&sub_frame_gradient, 
			wtk_slider_get_value(slider[0]),
			wtk_slider_get_value(slider[1]),
			wtk_slider_get_value(slider[2]),
			wtk_slider_get_value(slider[3]),
			wtk_slider_get_value(slider[4]),
			wtk_slider_get_value(slider[5]),
			280, gradient_option);

		win_redraw(wtk_basic_frame_as_child(sub_frame));
		break;

	case BUTTON_MIRROR_ID:
		//Set options to enable mirrored gradients.
		gradient_option ^= GFX_GRADIENT_MIRROR;
		gfx_gradient_set_options(&sub_frame_gradient, gradient_option);
		win_redraw(wtk_basic_frame_as_child(sub_frame));
		break;

	case BUTTON_INVERT_ID:
		//Set options to enable inverted gradients.
		gradient_option ^= GFX_GRADIENT_INVERT;
		gfx_gradient_set_options(&sub_frame_gradient, gradient_option);
		win_redraw(wtk_basic_frame_as_child(sub_frame));
		break;

	}

	return false;
}


/**
 * \brief Setup widget demo
 *
 * This function launches the widget demo.
 *
 * \param task Workqueue task used to start the application.
 */
void app_widget_launch(struct workqueue_task *task) {

	struct win_window       *win_root;
	struct win_window       *parent;
	struct win_area         area;
	struct wtk_label        *lbl;
	struct wtk_button       *btn_draw;
	struct wtk_button       *btn_mirror;
	struct wtk_button       *btn_invert;

	// Use larger sysfont for this app
	sysfont.scale = 2;

	// Get pointer to root window
	win_root = win_get_root();

	// Application frame

	// Create a background bitmap using a solid color.
	frame_background.type = BITMAP_SOLID;
	frame_background.data.color = APP_BACKGROUND_COLOR;

	// Set the area to fill the entire screen
	area.pos.x = 0;
	area.pos.y = 0;
	area.size.x = gfx_get_width();
	area.size.y = gfx_get_height();

	/*
	 * Create a basic frame with a specified background and command event
	 * handler. Check the return value if an error occured while creating
	 * the widget.
	 */
	frame = wtk_basic_frame_create(win_root, &area,
			&frame_background, NULL,
			widget_frame_command_handler, NULL);
	if (!frame) {
		goto error_frame;
	}

	// Get a pointer to the widget's window for adding sub-widgets.
	parent = wtk_basic_frame_as_child(frame);
	/*
	 * Draw the frame by showing the frame widget's window. Any
	 * child-widgets and windows will not be shown before the parent
	 * widget/window is shown.
	 */
	win_show(parent);

	// Application label
	area.pos.x = LABEL_POS_X;
	area.pos.y = LABEL_POS_Y;
	// Find an optimal size for the widget.
	wtk_label_size_hint(&area.size, demo_string);

	/*
	 * Create the label and check the return value if an error occured
	 * while creating the label.
	 */
	lbl = wtk_label_create(parent, &area, demo_string, false);
	if (!lbl) {
		goto error_widget;
	}

	// Draw the label by showing the label widget's window.
	win_show(wtk_label_as_child(lbl));

	// Slider
	area.pos.x = SLIDER_POS_X;
	area.pos.y = SLIDER_POS_Y;
	area.size.x = SLIDER_SIZE_X;
	area.size.y = SLIDER_SIZE_Y;

	/*
	 * Create the sliders and check the return values if an error occured
	 * while creating the sliders.
	 */
	for(uint8_t i=0; i<6; i++)
	{
		slider[i] = wtk_slider_create(parent, &area, SLIDER_MAX_VALUE,
				0, WTK_SLIDER_HORIZONTAL,0);
		if (!slider[i]) {
			goto error_widget;
		}
		area.pos.y += SLIDER_SIZE_Y + SLIDER_SPACING_Y;

		if (i == 2)
		{
			area.pos.x=SLIDER_POS_X + SLIDER_SPACING_X ;
			area.pos.y=SLIDER_POS_Y;
		}
	}
	// set initial values.
	wtk_slider_set_value(slider[0], 255);
	wtk_slider_set_value(slider[5], 255);


	// Draw the sliders by showing the slider widget's window.
	win_show(wtk_slider_as_child(slider[0]));
	win_show(wtk_slider_as_child(slider[1]));
	win_show(wtk_slider_as_child(slider[2]));
	win_show(wtk_slider_as_child(slider[3]));
	win_show(wtk_slider_as_child(slider[4]));
	win_show(wtk_slider_as_child(slider[5]));

	//set up buttons.
	area.pos.x = SLIDER_POS_X + BUTTON_SPACING_X;
	area.pos.y = BUTTON_POS_Y;

	area.size.x = BUTTON_SIZE_X;
	area.size.y = BUTTON_SIZE_Y;

	btn_draw = wtk_button_create(parent, &area, "Update",
			(win_command_t)BUTTON_UPDATE_ID);
	if (!btn_draw) {
		goto error_widget;
	}
	win_show(wtk_button_as_child(btn_draw));

	area.pos.y += BUTTON_SIZE_Y + BUTTON_SPACING_Y;

	btn_invert = wtk_button_create(parent, &area, "Invert",
			(win_command_t)BUTTON_INVERT_ID);
	if (!btn_invert) {
		goto error_widget;
	}
	win_show(wtk_button_as_child(btn_invert));

	area.pos.y += BUTTON_SIZE_Y + BUTTON_SPACING_Y;

	btn_mirror = wtk_button_create(parent, &area, "Mirror",
			(win_command_t)BUTTON_MIRROR_ID);
	if (!btn_mirror) {
		goto error_widget;
	}
	win_show(wtk_button_as_child(btn_mirror));

	// Set up basic frame, using a gradient background.
	area.pos.x = FRAME_POS_X;
	area.pos.y = FRAME_POS_Y;

	area.size.x = FRAME_SIZE_X;
	area.size.y = FRAME_SIZE_Y;

	gfx_gradient_set_values(&sub_frame_gradient, 255, 0, 0, 0, 0, 255,
			FRAME_SIZE_X, GFX_GRADIENT_HORIZONTAL);
	gradient_option=GFX_GRADIENT_HORIZONTAL;
	sub_frame_background.type = BITMAP_GRADIENT;
	sub_frame_background.width = FRAME_SIZE_X;
	sub_frame_background.height = FRAME_SIZE_Y;
	sub_frame_background.data.gradient = &sub_frame_gradient;

	sub_frame = wtk_basic_frame_create(parent, &area,
			&sub_frame_background, NULL, NULL, NULL);
			
	if (!sub_frame) {
		goto error_widget;
	}
	win_show(wtk_basic_frame_as_child(sub_frame));

	return;

error_widget:
	// Destroy widget and all sub-widgets.
	win_destroy(wtk_basic_frame_as_child(frame));
error_frame:
	// Wait forever if an error occured during setup.
	while(1);
}

//! @}
